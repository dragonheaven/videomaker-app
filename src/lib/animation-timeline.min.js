!(function (e, t) { typeof exports === 'object' && typeof module === 'object' ? module.exports = t() : typeof define === 'function' && define.amd ? define([], t) : typeof exports === 'object' ? exports.timelineModule = t() : e.timelineModule = t(); }(window, (() => (function (e) { const t = {}; function n(i) { if (t[i]) return t[i].exports; const r = t[i] = { i, l: !1, exports: {} }; return e[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports; } return n.m = e, n.c = t, n.d = function (e, t, i) { n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: i }); }, n.r = function (e) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(e, '__esModule', { value: !0 }); }, n.t = function (e, t) { if (1 & t && (e = n(e)), 8 & t) return e; if (4 & t && typeof e === 'object' && e && e.__esModule) return e; const i = Object.create(null); if (n.r(i), Object.defineProperty(i, 'default', { enumerable: !0, value: e }), 2 & t && typeof e !== 'string') for (const r in e)n.d(i, r, ((t) => e[t]).bind(null, r)); return i; }, n.n = function (e) { const t = e && e.__esModule ? function () { return e.default; } : function () { return e; }; return n.d(t, 'a', t), t; }, n.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t); }, n.p = '', n(n.s = 18); }([function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t, n) {
  function i(e, t) { for (let n = 0; n < t.length; n++) { const i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } }n.r(t), n.d(t, 'Timeline', (() => Ce)), n.d(t, 'TimelineModel', (() => Te.TimelineModel)), n.d(t, 'TimelineRow', (() => Pe.TimelineRow)), n.d(t, 'TimelineKeyframe', (() => Re.TimelineKeyframe)), n.d(t, 'TimelineEventsEmitter', (() => r)), n.d(t, 'TimelineConsts', (() => Ee.TimelineConsts)), n.d(t, 'TimelineRanged', (() => De.TimelineRanged)), n.d(t, 'TimelineOptions', (() => Oe.TimelineOptions)), n.d(t, 'TimelineKeyframeStyle', (() => Ke.TimelineKeyframeStyle)), n.d(t, 'TimelineRowStyle', (() => ze.TimelineRowStyle)), n.d(t, 'TimelineStyle', (() => Ne.TimelineStyle)), n.d(t, 'TimelineStyleUtils', (() => v)), n.d(t, 'TimelineUtils', (() => c)), n.d(t, 'TimelineElement', (() => Le.TimelineElement)), n.d(t, 'Selectable', (() => je.Selectable)), n.d(t, 'TimelineCutBoundsRectResults', (() => Ae.TimelineCutBoundsRectResults)), n.d(t, 'TimelineSelectionResults', (() => Ve.TimelineSelectionResults)), n.d(t, 'TimelineValues', (() => We.TimelineValues)), n.d(t, 'TimelineMouseData', (() => Fe.TimelineMouseData)), n.d(t, 'TimelineElementDragState', (() => Be.TimelineElementDragState)), n.d(t, 'TimelineDraggableData', (() => Be.TimelineDraggableData)), n.d(t, 'TimelineModelCalcResults', (() => Ie.TimelineModelCalcResults)), n.d(t, 'TimelineCalculatedRow', (() => Ie.TimelineCalculatedRow)), n.d(t, 'TimelineCalculatedGroup', (() => Ie.TimelineCalculatedGroup)), n.d(t, 'TimelineCalculated', (() => Ie.TimelineCalculated)), n.d(t, 'TimelineCalculatedKeyframe', (() => Ie.TimelineCalculatedKeyframe)), n.d(t, 'TimelineKeyframeChangedEvent', (() => ve)), n.d(t, 'TimelineTimeChangedEvent', (() => le)), n.d(t, 'TimelineSelectedEvent', (() => C)), n.d(t, 'TimelineScrollEvent', (() => Ze.TimelineScrollEvent)), n.d(t, 'TimelineClickEvent', (() => N)), n.d(t, 'TimelineDragEvent', (() => U)), n.d(t, 'TimelineEvents', (() => f)), n.d(t, 'TimelineKeyframeShape', (() => a)), n.d(t, 'TimelineInteractionMode', (() => d)), n.d(t, 'TimelineElementType', (() => h)), n.d(t, 'TimelineCursorType', (() => l)), n.d(t, 'TimelineCapShape', (() => _)), n.d(t, 'TimelineEventSource', (() => Z)), n.d(t, 'TimelineSelectionMode', (() => oe)), n.d(t, 'defaultTimelineOptions', (() => X)), n.d(t, 'defaultTimelineKeyframeStyle', (() => G)), n.d(t, 'defaultTimelineRowStyle', (() => Y)), n.d(t, 'defaultTimelineStyle', (() => H)), n.d(t, 'defaultTimelineConsts', (() => q)); var r = (function () {
    function e() {
      let t; let n; let i; !(function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, e)), i = [], (n = '_subscriptions') in (t = this) ? Object.defineProperty(t, n, {
        value: i, enumerable: !0, configurable: !0, writable: !0,
      }) : t[n] = i;
    } let t; let n; let r; return t = e, (n = [{ key: 'on', value(e, t) { t && this._subscriptions.push({ topic: e, callback: t }); } }, { key: 'off', value(e, t) { this._subscriptions = this._subscriptions.filter(((n) => n && n.callback != t && n.topic != e)); } }, { key: 'offAll', value() { this._subscriptions.length = 0; } }, { key: 'emit', value(e, t) { this._subscriptions.forEach(((n) => { n && n.topic == e && n.callback && n.callback(t); })); } }]) && i(t.prototype, n), r && i(t, r), e;
  }()); function o(e, t) { for (let n = 0; n < t.length; n++) { const i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } let l; let a; const s = [1, 2, 5, 10]; var c = (function () { function e() { !(function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, e)); } let t; let n; let i; return t = e, i = [{ key: 'drawLine', value(e, t, n, i, r) { e.moveTo(t, n), e.lineTo(i, r); } }, { key: 'isNumber', value(e) { return !(typeof e !== 'number' || isNaN(e) || !Number.isFinite(e)); } }, { key: 'deleteElement', value(e, t) { const n = e.indexOf(t); return n !== -1 ? e.splice(n, 1) : e; } }, { key: 'isOverlap', value(e, t, n) { return !!n && n.x <= e && n.x + n.width >= e && n.y <= t && n.y + n.height >= t; } }, { key: 'findGoodStep', value(t) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; if (t <= 0 || isNaN(t) || !Number.isFinite(t)) return t; for (var i = t, r = null, o = e.getPowArgument(t), l = 0; l < s.length; l++) { const a = s[l]; const c = a * Math.pow(10, o); if (!n || n % c == 0) { const u = e.getDistance(t, c); if (u == 0 || u <= 0.1 && o > 0) { r = u, i = c; break; }(!r || r > u) && (r = u, i = c); } } return i; } }, { key: 'keepInBounds', value(t) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; return e.isNumber(t) && (e.isNumber(n) && (t = Math.max(t, n)), e.isNumber(i) && (t = Math.min(t, i))), t; } }, { key: 'setMinMax', value(t, n) { const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; if (!n || !t) return t; const r = Math.min(n.getMin ? n.getMin() : n.min, n.min); const o = Math.min(t.getMin ? t.getMin() : t.min, t.min); const l = e.isNumber(r); const a = e.isNumber(o); l && a ? t.min = i ? Math.min(r, o) : Math.max(r, o) : l && (t.min = r); const s = Math.min(n.getMax && n.getMax ? n.getMax() : n.max, n.max); const c = Math.min(t.getMax ? t.getMax() : t.max, t.max); const u = e.isNumber(s); const h = e.isNumber(c); return u && h ? t.max = i ? Math.max(s, c) : Math.min(s, c) : u && (t.max = s), t; } }, { key: 'isRectOverlap', value(e, t) { return e && t ? e.x > t.x + t.width || t.x > e.x + e.width || e.y < t.y + t.height || t.y < e.y + e.height : (console.log('Rectangles cannot be empty'), !1); } }, { key: 'getDistance', value(e, t, n, i) { return n != null && i != null ? Math.sqrt(Math.pow(e - n, 2) + Math.pow(t - i, 2)) : Math.abs(e - t); } }, { key: 'sign', value(e) { return e >= 0 ? 1 : -1; } }, { key: 'clearBrowserSelection', value() { if (window) if (window.getSelection)window.getSelection().removeAllRanges(); else { const e = window.document; e.selection && e.selection.empty(); } } }, { key: 'getPowArgument', value(e) { if (!e || e === 0 || !isFinite(e)) return 1; if (e >= 10 && e < 100) return 1; if (e >= 100 && e < 1e3) return 2; if (e >= 1e3 && e < 1e4) return 3; e = Math.abs(e); let t = 0; const n = this.sign(e); if (e > 1) { for (;e >= 1;)e = Math.floor(e / 10), t++; return n * t - 1; } return e > 0 ? Math.floor(Math.log(e) / Math.log(10) + 1) - 1 : 1; } }], (n = null) && o(t.prototype, n), i && o(t, i), e; }()); function u(e, t) { for (let n = 0; n < t.length; n++) { const i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } }!(function (e) { e.Alias = 'alias', e.AllScroll = 'all-scroll', e.Auto = 'auto', e.Cell = 'cell', e.ContextMenu = 'context-menu', e.ColResize = 'col-resize', e.Copy = 'copy', e.Crosshair = 'crosshair', e.Default = 'default', e.EResize = 'e-resize', e.EWResize = 'ew-resize', e.Grab = 'grab', e.Grabbing = 'grabbing', e.Help = 'help', e.Move = 'move', e.NResize = 'n-resize', e.NEResize = 'ne-resize', e.NESWResize = 'nesw-resize', e.NSResize = 'ns-resize', e.NWResize = 'nw-resize', e.NWSEResize = 'nwse-resize', e.NoDrop = 'no-drop', e.None = 'none', e.NotAllowed = 'not-allowed', e.Pointer = 'pointer', e.Progress = 'progress', e.RowResize = 'row-resize', e.SResize = 's-resize', e.SEResize = 'se-resize', e.SWResize = 'sw-resize', e.Text = 'text', e.WResize = 'w-resize', e.Wait = 'wait', e.ZoomIn = 'zoom-in', e.ZoomOut = 'zoom-out'; }(l || (l = {}))), (function (e) { e.None = 'none', e.Rhomb = 'rhomb', e.Circle = 'circle', e.Rect = 'rect'; }(a || (a = {}))); let h; let f; let _; let d; var v = (function () { function e() { !(function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, e)); } let t; let n; let i; return t = e, i = [{ key: 'getKeyframeStyle', value(e, t, n, i, r) { const o = arguments.length > 5 && void 0 !== arguments[5] && arguments[5]; let l = null; if (e) { const a = e; if (void 0 !== a[i]) { const s = a[i]; if (!o) return s; (l = l || []).push(s); } } if (t && t.keyframesStyle) { const c = t.keyframesStyle; if (void 0 !== c[i]) { const u = c[i]; if (!o) return u; (l = l || []).push(u); } } const h = n ? n.rowsStyle : null; if (h && h.keyframesStyle) { const f = h.keyframesStyle; if (void 0 !== f[i]) { const _ = f[i]; if (!o) return _; (l = l || []).push(_); } } return o && l && l.length > 0 ? l[l.length - 1] : r; } }, { key: 'getRowStyle', value(e, t, n, i) { const r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; let o = null; if (e) { const l = e; if (void 0 !== l[n]) { const a = l[n]; if (!r) return a; (o = o || []).push(a); } } const s = t ? t.rowsStyle : null; if (s) { const c = s; if (void 0 !== c[n]) { const u = c[n]; if (!r) return u; (o = o || []).push(u); } } return r && o && o.length > 0 ? o[o.length - 1] : i; } }, { key: 'keyframeShape', value(t, n, i) { return e.getKeyframeStyle(t, n, i, 'shape', a.Rhomb); } }, { key: 'keyframeFillColor', value(t, n, i) { return e.getKeyframeStyle(t, n, i, 'fillColor', 'DarkOrange'); } }, { key: 'keyframeSelectedFillColor', value(t, n, i) { return e.getKeyframeStyle(t, n, i, 'selectedFillColor', 'red'); } }, { key: 'keyframeStrokeThickness', value(t, n, i) { return e.getKeyframeStyle(t, n, i, 'strokeThickness', 0.2, !1); } }, { key: 'keyframeStrokeColor', value(t, n, i) { return e.getKeyframeStyle(t, n, i, 'strokeColor', 'Black', !1); } }, { key: 'keyframeSelectedStrokeColor', value(t, n, i) { return e.getKeyframeStyle(t, n, i, 'selectedStrokeColor', 'Black', !1); } }, { key: 'getRowHeight', value(t, n) { return e.getRowStyle(t, n, 'height', 24); } }, { key: 'rowGroupHeight', value(t, n) { return e.getRowStyle(t, n, 'groupHeight', 'auto'); } }, { key: 'groupFillColor', value(t, n) { return e.getRowStyle(t, n, 'groupFillColor'); } }, { key: 'getRowMarginBottom', value(t, n) { return e.getRowStyle(t, n, 'marginBottom', 0); } }, { key: 'getRowFillColor', value(t, n) { return e.getRowStyle(t, n, 'fillColor', '#252526'); } }, { key: 'headerHeight', value(e) { return e ? e.headerHeight : 30; } }, { key: 'keyframeDraggable', value(t, n, i) { const r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]; return e.getKeyframeStyle(t, n, i, 'draggable', r, !1); } }, { key: 'groupDraggable', value(t, n) { const i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; return e.getRowStyle(t, n, 'groupDraggable', i, !1); } }], (n = null) && u(t.prototype, n), i && u(t, i), e; }()); function p(e, t) { for (let n = 0; n < t.length; n++) { const i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } }!(function (e) { e.Timeline = 'timeline', e.Keyframe = 'keyframe', e.Group = 'group', e.Row = 'row'; }(h || (h = {}))), (function (e) { e.Selected = 'selected', e.TimeChanged = 'timechanged', e.KeyframeChanged = 'keyframeChanged', e.DragStarted = 'dragStarted', e.Drag = 'drag', e.DragFinished = 'dragFinished', e.Scroll = 'scroll', e.DoubleClick = 'doubleClick', e.MouseDown = 'mouseDown'; }(f || (f = {}))), (function (e) { e.None = 'none', e.Triangle = 'triangle', e.Rect = 'rect'; }(_ || (_ = {}))), (function (e) { e.Selection = 'selection', e.Pan = 'pan', e.Zoom = 'zoom'; }(d || (d = {}))); const m = (function () {
    function e() {
      let t; let n; let i; !(function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, e)), i = !1, (n = '_prevented') in (t = this) ? Object.defineProperty(t, n, {
        value: i, enumerable: !0, configurable: !0, writable: !0,
      }) : t[n] = i;
    } let t; let n; let i; return t = e, (n = [{ key: 'preventDefault', value() { this._prevented = !0; } }, { key: 'isPrevented', value() { return this._prevented; } }]) && p(t.prototype, n), i && p(t, i), e;
  }()); function y(e) { return (y = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; })(e); } function g(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function w(e, t) { return (w = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e; })(e, t); } function b(e) { const t = (function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (() => {}))), !0; } catch (e) { return !1; } }()); return function () { let n; const i = S(e); if (t) { const r = S(this).constructor; n = Reflect.construct(i, arguments, r); } else n = i.apply(this, arguments); return k(this, n); }; } function k(e, t) { return !t || y(t) !== 'object' && typeof t !== 'function' ? x(e) : t; } function x(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; } function S(e) { return (S = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e); })(e); } function M(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
      value: n, enumerable: !0, configurable: !0, writable: !0,
    }) : e[t] = n, e;
  } var C = (function (e) { !(function (e, t) { if (typeof t !== 'function' && t !== null) throw new TypeError('Super expression must either be null or a function'); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && w(e, t); }(n, e)); const t = b(n); function n() { let e; g(this, n); for (var i = arguments.length, r = new Array(i), o = 0; o < i; o++)r[o] = arguments[o]; return M(x(e = t.call.apply(t, [this].concat(r))), 'selected', []), M(x(e), 'changed', []), e; } return n; }(m)); function T(e) { return (T = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; })(e); } function P(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function R(e, t) { return (R = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e; })(e, t); } function E(e) { const t = (function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (() => {}))), !0; } catch (e) { return !1; } }()); return function () { let n; const i = K(e); if (t) { const r = K(this).constructor; n = Reflect.construct(i, arguments, r); } else n = i.apply(this, arguments); return D(this, n); }; } function D(e, t) { return !t || T(t) !== 'object' && typeof t !== 'function' ? O(e) : t; } function O(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; } function K(e) { return (K = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e); })(e); } function z(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
      value: n, enumerable: !0, configurable: !0, writable: !0,
    }) : e[t] = n, e;
  } var N = (function (e) { !(function (e, t) { if (typeof t !== 'function' && t !== null) throw new TypeError('Super expression must either be null or a function'); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && R(e, t); }(n, e)); const t = E(n); function n() { let e; P(this, n); for (var i = arguments.length, r = new Array(i), o = 0; o < i; o++)r[o] = arguments[o]; return z(O(e = t.call.apply(t, [this].concat(r))), 'args', void 0), z(O(e), 'pos', void 0), z(O(e), 'elements', void 0), z(O(e), 'target', void 0), z(O(e), 'val', void 0), z(O(e), 'snapVal', void 0), z(O(e), 'originalVal', void 0), e; } return n; }(m)); function L(e) { return (L = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; })(e); } function j(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function A(e, t) { return (A = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e; })(e, t); } function V(e) { const t = (function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (() => {}))), !0; } catch (e) { return !1; } }()); return function () { let n; const i = B(e); if (t) { const r = B(this).constructor; n = Reflect.construct(i, arguments, r); } else n = i.apply(this, arguments); return W(this, n); }; } function W(e, t) { return !t || L(t) !== 'object' && typeof t !== 'function' ? F(e) : t; } function F(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; } function B(e) { return (B = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e); })(e); } function I(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
      value: n, enumerable: !0, configurable: !0, writable: !0,
    }) : e[t] = n, e;
  } let Z; var U = (function (e) { !(function (e, t) { if (typeof t != 'function' && t !== null) throw new TypeError('Super expression must either be null or a function'); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && A(e, t); }(n, e)); const t = V(n); function n() { let e; j(this, n); for (var i = arguments.length, r = new Array(i), o = 0; o < i; o++)r[o] = arguments[o]; return I(F(e = t.call.apply(t, [this].concat(r))), 'args', void 0), I(F(e), 'pos', void 0), I(F(e), 'elements', void 0), I(F(e), 'target', void 0), I(F(e), 'val', void 0), I(F(e), 'prevVal', void 0), I(F(e), 'snapVal', void 0), I(F(e), 'originalVal', void 0), e; } return n; }(m)); var H = {
    width: 2, marginTop: 15, capWidth: 4, capHeight: 10, capType: _.Rect, strokeColor: 'DarkOrange', fillColor: 'DarkOrange',
  }; var G = {
    fillColor: 'DarkOrange', shape: a.Rhomb, selectedFillColor: 'red', strokeColor: 'black', selectedStrokeColor: 'black', strokeThickness: 0.2, draggable: !0,
  }; var Y = {
    height: 24, marginBottom: 2, fillColor: '#252526', groupFillColor: '#094771', groupHeight: 'auto', keyframesStyle: G,
  }; var X = {
    snapAllKeyframesOnMove: !1, snapEnabled: !0, timelineStyle: H, stepPx: 120, stepVal: 1e3, stepSmallPx: 30, snapStep: 200, leftMargin: 25, headerFillColor: '#101011', fillColor: '#101011', labelsColor: '#D5D5D5', tickColor: '#D5D5D5', selectionColor: 'White', rowsStyle: Y, headerHeight: 30, font: '11px sans-serif', zoom: 1, zoomSpeed: 0.1, zoomMin: 0.1, zoomMax: 8, controlKeyIsMetaKey: !1, scrollContainerClass: 'scroll-container', groupsDraggable: !0, keyframesDraggable: !0, min: 0, max: Number.MAX_VALUE,
  }; var q = {
    autoPanSpeed: 50, scrollByDragSpeed: 0.12, clickDetectionMs: 120, doubleClickTimeoutMs: 400, scrollFinishedTimeoutMs: 500, autoPanByScrollPadding: 10, clickThreshold: 3,
  }; function J(e) { return (J = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; })(e); } function Q(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function $(e, t) { return ($ = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e; })(e, t); } function ee(e) { const t = (function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (() => {}))), !0; } catch (e) { return !1; } }()); return function () { let n; const i = ie(e); if (t) { const r = ie(this).constructor; n = Reflect.construct(i, arguments, r); } else n = i.apply(this, arguments); return te(this, n); }; } function te(e, t) { return !t || J(t) !== 'object' && typeof t !== 'function' ? ne(e) : t; } function ne(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; } function ie(e) { return (ie = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e); })(e); } function re(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
      value: n, enumerable: !0, configurable: !0, writable: !0,
    }) : e[t] = n, e;
  }!(function (e) { e.User = 'user', e.Programmatically = 'programmatically', e.SetTimeMethod = 'setTimeMethod'; }(Z || (Z = {}))); let oe; var le = (function (e) { !(function (e, t) { if (typeof t !== 'function' && t !== null) throw new TypeError('Super expression must either be null or a function'); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && $(e, t); }(n, e)); const t = ee(n); function n() { let e; Q(this, n); for (var i = arguments.length, r = new Array(i), o = 0; o < i; o++)r[o] = arguments[o]; return re(ne(e = t.call.apply(t, [this].concat(r))), 'val', 0), re(ne(e), 'prevVal', 0), re(ne(e), 'source', Z.User), e; } return n; }(m)); function ae(e) { return (ae = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; })(e); } function se(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function ce(e, t) { return (ce = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e; })(e, t); } function ue(e) { const t = (function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (() => {}))), !0; } catch (e) { return !1; } }()); return function () { let n; const i = _e(e); if (t) { const r = _e(this).constructor; n = Reflect.construct(i, arguments, r); } else n = i.apply(this, arguments); return he(this, n); }; } function he(e, t) { return !t || ae(t) !== 'object' && typeof t !== 'function' ? fe(e) : t; } function fe(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; } function _e(e) { return (_e = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e); })(e); } function de(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
      value: n, enumerable: !0, configurable: !0, writable: !0,
    }) : e[t] = n, e;
  }!(function (e) { e.Normal = 'normal', e.Append = 'append', e.Revert = 'revert'; }(oe || (oe = {}))); var ve = (function (e) { !(function (e, t) { if (typeof t !== 'function' && t !== null) throw new TypeError('Super expression must either be null or a function'); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && ce(e, t); }(n, e)); const t = ue(n); function n() { let e; se(this, n); for (var i = arguments.length, r = new Array(i), o = 0; o < i; o++)r[o] = arguments[o]; return de(fe(e = t.call.apply(t, [this].concat(r))), 'val', void 0), de(fe(e), 'prevVal', void 0), de(fe(e), 'target', void 0), de(fe(e), 'source', void 0), e; } return n; }(m)); function pe(e) { return (pe = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; })(e); } function me(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function ye(e, t) { for (let n = 0; n < t.length; n++) { const i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } function ge(e, t) { return (ge = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e; })(e, t); } function we(e) { const t = (function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (() => {}))), !0; } catch (e) { return !1; } }()); return function () { let n; const i = Se(e); if (t) { const r = Se(this).constructor; n = Reflect.construct(i, arguments, r); } else n = i.apply(this, arguments); return be(this, n); }; } function be(e, t) { return !t || pe(t) !== 'object' && typeof t !== 'function' ? ke(e) : t; } function ke(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; } function xe(e, t, n) { return (xe = typeof Reflect !== 'undefined' && Reflect.get ? Reflect.get : function (e, t, n) { const i = (function (e, t) { for (;!Object.prototype.hasOwnProperty.call(e, t) && (e = Se(e)) !== null;);return e; }(e, t)); if (i) { const r = Object.getOwnPropertyDescriptor(i, t); return r.get ? r.get.call(n) : r.value; } })(e, t, n || e); } function Se(e) { return (Se = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e); })(e); } function Me(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
      value: n, enumerable: !0, configurable: !0, writable: !0,
    }) : e[t] = n, e;
  } var Ce = (function (e) {
    !(function (e, t) { if (typeof t !== 'function' && t !== null) throw new TypeError('Super expression must either be null or a function'); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && ge(e, t); }(o, e)); let t; let n; let i; const r = we(o); function o() {
      let e; let t; let n; const i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; const a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; return me(this, o), Me(ke(n = r.call(this)), '_container', null), Me(ke(n), '_canvas', null), Me(ke(n), '_scrollContainer', null), Me(ke(n), '_scrollContent', null), Me(ke(n), '_ctx', null), Me(ke(n), '_options', null), Me(ke(n), '_startPos', null), Me(ke(n), '_scrollStartPos', { x: 0, y: 0 }), Me(ke(n), '_currentPos', null), Me(ke(n), '_selectionRect', null), Me(ke(n), '_selectionRectEnabled', !1), Me(ke(n), '_drag', null), Me(ke(n), '_startedDragWithCtrl', !1), Me(ke(n), '_startedDragWithShiftKey', !1), Me(ke(n), '_clickTimeout', 0), Me(ke(n), '_lastClickTime', 0), Me(ke(n), '_lastClickPoint', null), Me(ke(n), '_consts', q), Me(ke(n), '_clickAllowed', !1), Me(ke(n), '_scrollFinishedTimerRef', null), Me(ke(n), '_val', 0), Me(ke(n), '_pixelRatio', 1), Me(ke(n), '_currentZoom', 0), Me(ke(n), '_intervalRef', null), Me(ke(n), '_autoPanLastActionDate', 0), Me(ke(n), '_isPanStarted', !1), Me(ke(n), '_interactionMode', d.Selection), Me(ke(n), '_lastUsedArgs', null), Me(ke(n), '_model', null), Me(ke(n), '_handleKeyUp', ((e) => { n._interactionMode === d.Zoom && n._setZoomCursor(e); })), Me(ke(n), '_handleKeyDown', ((e) => { n._interactionMode === d.Zoom && n._setZoomCursor(e); })), Me(ke(n), '_handleBlurEvent', (() => { n._cleanUpSelection(); })), Me(ke(n), '_handleWindowResizeEvent', (() => { n.rescale(), n.redraw(); })), Me(ke(n), '_handleScrollEvent', ((e) => { n._clearScrollFinishedTimer(), n._scrollFinishedTimerRef = setTimeout((() => { n._isPanStarted || (n._scrollFinishedTimerRef && (clearTimeout(n._scrollFinishedTimerRef), n._scrollFinishedTimerRef = null), n.rescale(), n.redraw()); }), n._consts.scrollFinishedTimeoutMs), n.redraw(), n._emitScrollEvent(e); })), Me(ke(n), '_handleWheelEvent', ((e) => { if (n._controlKeyPressed(e)) { e.preventDefault(); const t = Math.max(0, n._getMousePos(n._canvas, e).x || 0); n._zoom(c.sign(e.deltaY), n._options.zoomSpeed, t); } else n._scrollContainer.scrollTop += e.deltaY, e.preventDefault(); })), Me(ke(n), '_handleMouseDownEvent', ((i) => {
        let r = Date.now() - n._lastClickTime < n._consts.doubleClickTimeoutMs; if (c.clearBrowserSelection(), n._startPos = n._trackMousePos(n._canvas, i), n._startPos) {
          n._lastClickPoint && n._startPos && c.getDistance(n._lastClickPoint.x, n._lastClickPoint.y, n._startPos.x, n._startPos.y) > n._consts.clickThreshold && (r = !1), n._lastClickPoint = n._startPos, n._scrollStartPos = { x: n._scrollContainer.scrollLeft, y: n._scrollContainer.scrollTop }, n._clickAllowed = !0; const l = n.elementFromPoint(n._startPos, Math.max(2, n._startPos.radius)); const a = n._findDraggable(l, n._startPos.val); const s = new N(); if (s.pos = n._startPos, s.val = n._startPos.val, s.originalVal = n._startPos.originalVal, s.snapVal = n._startPos.snapVal, s.args = i, s.elements = l, s.target = a, r)xe((e = ke(n), Se(o.prototype)), 'emit', e).call(e, f.DoubleClick, s); else if (xe((t = ke(n), Se(o.prototype)), 'emit', t).call(t, f.MouseDown, s), n._clickTimeout = Date.now(), n._lastClickTime = Date.now(), s.isPrevented())n._cleanUpSelection(); else {
            if (n._currentPos = n._startPos, a && n._interactionMode !== d.Zoom) {
 if (n._drag = {
              changed: !1, target: n._setElementDragState(a, a.val), val: a.val, type: a.type, elements: [],
            }, a.type === h.Keyframe)n._startedDragWithCtrl = n._controlKeyPressed(i), n._startedDragWithShiftKey = i.shiftKey, a.keyframe.selected || n._controlKeyPressed(i) || n._selectInternal(a.keyframe), n._drag.elements = n.getSelectedElements().map(((e) => n._setElementDragState(e, e.val))); else if (a.type === h.Group) { const u = n._drag.target.keyframes; u && Array.isArray(u) && (n._drag.elements = u.map(((e) => n._setElementDragState(n._convertToElement(n._drag.target.row, e), e.val)))); } else n._drag.elements = [n._drag.target];
            } n.redraw();
          }
        }
      })), Me(ke(n), '_handleMouseMoveEvent', ((e) => { if (e ? n._lastUsedArgs = e : e = n._lastUsedArgs, e) { const t = e.changedTouches && e.changedTouches.length > 0; n._currentPos = n._trackMousePos(n._canvas, e), !n._isPanStarted && n._selectionRect && n._clickTimeoutIsOver() ? n._selectionRectEnabled = n._interactionMode !== d.Zoom : n._selectionRectEnabled = !1, e = e; const i = n.isLeftButtonClicked(e); if (n._startPos) if (i || t) { if (n._drag && !n._startedDragWithCtrl) { const r = n._currentPos.val; if (n._drag.type === h.Timeline)n._setTimeInternal(r, Z.User); else if ((n._drag.type == h.Keyframe || n._drag.type == h.Group) && n._drag.elements) { const o = Math.floor(r - n._drag.val); if (n._moveElements(o, n._drag.elements, Z.User) !== 0) { if (!n._drag.changed) if (n._drag.prevVal = n._drag.val, n._emitDragStartedEvent().isPrevented()) return n._drag = null, void n._cleanUpSelection(); n._drag.changed = !0, n._drag.val += o, n._emitDragEvent(); } } }n._interactionMode !== d.Pan || n._drag ? n._scrollBySelectionOutOfBounds(n._currentPos) : (n._isPanStarted = !0, n._setCursor(l.Grabbing), n._scrollByPan(n._startPos, n._currentPos, n._scrollStartPos)), n.redraw(); } else n._cleanUpSelection(), n.redraw(); else if (!t) { const a = n.elementFromPoint(n._currentPos, Math.max(2, n._currentPos.radius)); const s = n._findDraggable(a, n._currentPos.val); if (n._isPanStarted || n._interactionMode === d.Pan)i ? n._setCursor(l.Grabbing) : n._setCursor(l.Grab); else { if (n._interactionMode === d.Zoom) return void n._setZoomCursor(e); n._setCursor(l.Default); } if (s) { let c = null; s.type === h.Group ? c = c || l.EWResize : s.type == h.Keyframe ? c = c || l.Pointer : s.type == h.Timeline && (c = c || l.EWResize), c && n._setCursor(c); } }t && e.preventDefault(); } })), Me(ke(n), '_handleMouseUpEvent', ((e) => { if (n._startPos) { const t = n._trackMousePos(n._canvas, e); if (n._clickAllowed || !n._clickTimeoutIsOver() || n._drag && (n._startedDragWithCtrl || n._startedDragWithShiftKey)) if (n._options && n._interactionMode === d.Zoom) { const i = n._controlKeyPressed(e) ? 1 : -1; const r = Math.max(0, n._getMousePos(n._canvas, e).x || 0); n._zoom(i, n._options.zoomSpeed, r); } else n._performClick(t, n._drag); else if (!n._drag && n._selectionRect && n._selectionRectEnabled) if (n._interactionMode === d.Zoom)n._selectionRect.width; else { const o = n._getKeyframesByRectangle(n._selectionRect); const l = e.shiftKey ? oe.Append : oe.Normal; n.select(o, l); }n._cleanUpSelection(), n.redraw(); } })), Me(ke(n), '_redrawInternal', (() => { n._ctx && (n.valToPx(n._val) > n._scrollContainer.scrollWidth && (n.rescale(), !n._isPanStarted && n._drag && n._drag.type !== h.Timeline && n.scrollLeft()), n._renderBackground(), n._renderRows(), n._renderHeaderBackground(), n._renderTicks(), n._renderKeyframes(), n._renderSelectionRect(), n._renderTimeline()); })), (i || a) && n.initialize(i, a), n;
    } return t = o, (n = [{ key: 'initialize', value(e, t) { if (this._model = t, !e || !e.id) throw new Error('Element cannot be empty. Should be string or DOM element.'); this._generateContainers(e.id), this._options = this._setOptions(e), this._subscribeOnEvents(), this.rescale(), this.redraw(); } }, { key: '_generateContainers', value(e) { if (e instanceof HTMLElement ? this._container = e : this._container = document.getElementById(e), !this._container) throw new Error('Element cannot be empty. Should be string or DOM element.'); if (this._scrollContainer = document.createElement('div'), this._scrollContent = document.createElement('div'), this._canvas = document.createElement('canvas'), !this._canvas || !this._canvas.getContext) return console.log('Cannot initialize canvas context.'), null; this._container.style.position = 'relative', this._canvas.style.cssText = 'image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;user-select: none;-webkit-user-select: none;-khtml-user-select: none;-moz-user-select: none;-o-user-select: none;user-select: none;touch-action: none;position: relative;-webkit-user-drag: none;-khtml-user-drag: none;-moz-user-drag: none;-o-user-drag: none;user-drag: none;padding: inherit', this._scrollContainer.style.cssText = 'overflow: scroll;position: absolute;width:  100%;height:  100%;', this._scrollContent.style.width = this._scrollContent.style.height = '100%', this._scrollContainer.appendChild(this._scrollContent), this._container.appendChild(this._scrollContainer); const t = this._scrollContainer.offsetWidth - this._scrollContent.clientWidth; this._canvas.style.width = this._canvas.style.height = `calc(100% -${t || 17}px)`, this._container.appendChild(this._canvas), this._ctx = this._canvas.getContext('2d'); } }, { key: '_subscribeOnEvents', value() { this._container.addEventListener('wheel', this._handleWheelEvent), this._scrollContainer && this._scrollContainer.addEventListener('scroll', this._handleScrollEvent), document.addEventListener('keyup', this._handleKeyUp, !1), document.addEventListener('keydown', this._handleKeyDown, !1), window.addEventListener('blur', this._handleBlurEvent, !1), window.addEventListener('resize', this._handleWindowResizeEvent, !1), this._canvas.addEventListener('touchstart', this._handleMouseDownEvent, !1), this._canvas.addEventListener('mousedown', this._handleMouseDownEvent, !1), window.addEventListener('mousemove', this._handleMouseMoveEvent, !1), window.addEventListener('touchmove', this._handleMouseMoveEvent, !1), window.addEventListener('mouseup', this._handleMouseUpEvent, !1), window.addEventListener('touchend', this._handleMouseUpEvent, !1); } }, { key: 'dispose', value() { this.offAll(), this._container = null, this._canvas = null, this._scrollContainer = null, this._scrollContent = null, this._ctx = null, this._cleanUpSelection(), this._container.removeEventListener('wheel', this._handleWheelEvent), this._scrollContainer && this._scrollContainer.removeEventListener('scroll', this._handleScrollEvent), window.removeEventListener('blur', this._handleBlurEvent), window.removeEventListener('resize', this._handleWindowResizeEvent), document.removeEventListener('keydown', this._handleKeyDown), document.removeEventListener('keyup', this._handleKeyUp), this._canvas.removeEventListener('touchstart', this._handleMouseDownEvent), this._canvas.removeEventListener('mousedown', this._handleMouseDownEvent), window.removeEventListener('mousemove', this._handleMouseMoveEvent), window.removeEventListener('touchmove', this._handleMouseMoveEvent), window.removeEventListener('mouseup', this._handleMouseUpEvent), window.removeEventListener('touchend', this._handleMouseUpEvent), this._stopAutoPan(), this._clearScrollFinishedTimer(); } }, { key: '_setZoomCursor', value(e) { this._controlKeyPressed(e) ? this._setCursor(l.ZoomOut) : this._setCursor(l.ZoomIn); } }, { key: '_clearScrollFinishedTimer', value() { this._scrollFinishedTimerRef && (clearTimeout(this._scrollFinishedTimerRef), this._scrollFinishedTimerRef = null); } }, { key: '_controlKeyPressed', value(e) { return this._options && void 0 !== this._options.controlKeyIsMetaKey ? this._options.controlKeyIsMetaKey || this._options.controlKeyIsMetaKey ? e.metaKey : e.ctrlKey : e.metaKey || e.ctrlKey; } }, { key: '_zoom', value(e, t, n) { if (t > 0 && t <= 1) { n += 0.2 * c.getDistance(this._width() / 2, n); const i = this._width() / n; const r = this._fromScreen(n); const o = e * this._currentZoom * t; this._currentZoom = this._setZoom(this._currentZoom + o); const l = this.valToPx(r); let a = Math.round(l - this._width() / i); a <= 0 && (a = 0), this._rescaleInternal(a + this._width(), null, 'zoom'), this._scrollContainer.scrollLeft != a && (this._scrollContainer.scrollLeft = a), this.redraw(); } } }, { key: 'zoomIn', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._options.zoomSpeed; this._zoom(1, e, this._scrollContainer.clientWidth / 2); } }, { key: 'zoomOut', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._options.zoomSpeed; this._zoom(-1, e, this._scrollContainer.clientWidth / 2); } }, { key: '_setZoom', value(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; return t = c.isNumber(t) ? t : this._options ? this._options.zoomMin : null, n = c.isNumber(n) ? n : this._options ? this._options.zoomMax : null, c.isNumber(e) ? (e = (e = c.keepInBounds(e, t, n)) || 1, this._currentZoom = e, e) : e; } }, { key: 'setZoom', value(e) { const t = this.getZoom(); if (t !== e) { const n = this._setZoom(e); if (t != n) return this.rescale(), this.redraw(), n; } return t; } }, { key: 'getZoom', value() { return c.isNumber(this._currentZoom) && this._currentZoom || 1; } }, { key: '_setElementDragState', value(e, t) { const n = e; return n.prevVal = n.val, void 0 !== n.startedVal && n.startedVal !== null || (n.startedVal = t), void 0 !== n.prevVal && n.prevVal !== null || (n.prevVal = t), n.val = t, n; } }, { key: 'isLeftButtonClicked', value(e) { return !!e && e.buttons == 1; } }, { key: '_moveElements', value(e, t) { const n = this; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Z.Programmatically; if (t) { let r = !1; if (Math.abs(e) > 0) { let o = { min: Number.MIN_SAFE_INTEGER, max: Number.MAX_SAFE_INTEGER }; if (o = c.setMinMax(o, this._options), t.forEach(((t) => { const i = c.setMinMax(c.setMinMax({ min: o.min, max: o.max }, t.keyframe), t.row); const r = (n._options && n._options.snapAllKeyframesOnMove ? n.snapVal(t.keyframe.val) : t.keyframe.val) + e; c.isNumber(i.min) && r < i.min && (e += c.getDistance(i.min, r)), c.isNumber(i.max) && r > i.max && (e -= c.getDistance(i.max, r)); })), Math.abs(e) > 0 && t.forEach(((t) => { const o = t.keyframe.val; const l = o + e; const a = n._setKeyframePos(t, l, i); r = a !== o; })), r) return e; } return 0; } } }, { key: '_height', value() { return this._canvas ? this._canvas.clientHeight : 0; } }, { key: '_width', value() { return this._canvas ? this._canvas.clientWidth : 0; } }, { key: '_mapKeyframes', value(e) { const t = []; if (!e) return t; for (let n = 0; n < e.length; n++)t.push(e[n].model || e[n].keyframe); return t; } }, { key: '_getKeyframesByRectangle', value(e) { const t = []; return this._forEachKeyframe(((n) => { c.isOverlap(n.size.x, n.size.y, e) && t.push(n.model); })), t; } }, { key: '_performClick', value(e, t) { let n = !1; if (t && t.type === h.Keyframe) { let i = oe.Normal; (this._startedDragWithCtrl && this._controlKeyPressed(e.args) || this._startedDragWithShiftKey && e.args.shiftKey) && this._controlKeyPressed(e.args) && (i = oe.Revert), n = this._selectInternal(this._drag.target.keyframe, i).selectionChanged || n, e.args.shiftKey && (n = this._setTimeInternal(e.val, Z.User) || n); } else n = this._selectInternal(null).selectionChanged || n, n = this._setTimeInternal(e.val, Z.User) || n; return n; } }, { key: '_setKeyframePos', value(e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Z.Programmatically; if (!e || !e.keyframe) return t; if (t = Math.floor(t), e.keyframe && e.keyframe.val != t) { e.prevVal = e.val, e.val = t, e.keyframe.val = t; const i = this._emitKeyframeChanged(e, n); return i.isPrevented() && (e.val = i.prevVal, e.keyframe.val = i.prevVal), t; } return t; } }, { key: '_setCursor', value(e) { this._canvas.style.cursor != e && (this._canvas.style.cursor = e); } }, { key: 'setInteractionMode', value(e) { this._interactionMode != e && (this._interactionMode = e, this._cleanUpSelection()); } }, { key: 'getInteractionMode', value() { return this._interactionMode; } }, {
      key: '_convertToElement',
      value(e, t) {
        return {
          type: h.Keyframe, val: t.val, keyframe: t, row: e,
        };
      },
    }, { key: 'getSelectedKeyframes', value() { return this._mapKeyframes(this.getSelectedElements()); } }, { key: 'getSelectedElements', value() { const e = this; const t = []; return this._forEachKeyframe(((n) => { n && n.model.selected && t.push(e._convertToElement(n.parentRow.model, n.model)); })), t; } }, { key: 'getAllKeyframes', value() { const e = []; return this._forEachKeyframe(((t) => { e.push(t.model); })), e; } }, { key: 'selectAllKeyframes', value() { return this.select(this.getAllKeyframes(), oe.Normal); } }, { key: 'deselectAll', value() { return this.select(null); } }, { key: '_changeNodeState', value(e, t, n) { if (t.selected !== n) { const i = typeof t.selectable !== 'boolean' || t.selectable; if (!n || n && i) return t.selected = n, e.changed.push(t), !0; } return !1; } }, { key: 'select', value(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : oe.Normal; const n = this._selectInternal(e, t); return n.selectionChanged && this.redraw(), n; } }, { key: '_selectInternal', value(e) { const t = this; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : oe.Normal; e || (e = []), Array.isArray(e) || (e = [e]); const i = { selectionChanged: !1, selected: this.getSelectedKeyframes(), changed: [] }; const r = e; if (this.getSelectedElements(), r && n === oe.Append)e.forEach(((e) => { t._changeNodeState(i, e, !0) && e.selected && i.selected.push(e); })); else if (r && n === oe.Revert)e.forEach(((e) => { i.selected.indexOf(e) >= 0 ? (t._changeNodeState(i, e, !1), c.deleteElement(i.selected, e)) : (t._changeNodeState(i, e, !0), e.selected && i.selected.push(e)); })); else if (n === oe.Normal) { const o = []; e && e.forEach(((e) => { t._changeNodeState(i, e, !0), e.selected && o.push(e); })), i.selected.forEach(((e) => { r.indexOf(e) >= 0 || t._changeNodeState(i, e, !1); })), i.changed.length > 0 && (o ? i.selected = o : i.selected.length = 0); } return i.changed.length > 0 && (i.selectionChanged = !0, this._emitKeyframesSelected(i)), i; } }, { key: '_forEachKeyframe', value(e) { if (e && this._model) { const t = this._calculateModel(); t && t.rows.forEach(((t) => { if (t) { let n = !0; t.keyframes.forEach(((t, i) => { t && e(t, i, n), n = !1; })); } })); } } }, { key: '_trackMousePos', value(e, t) { const n = this._getMousePos(e, t); if (n.originalVal = this._mousePosToVal(n.x, !1), n.snapVal = this._mousePosToVal(n.x, !0), n.val = n.originalVal, this._options && this._options.snapEnabled && (n.val = n.snapVal), this._startPos) { this._selectionRect || (this._selectionRect = {}); const i = Math.floor(this._startPos.x + (this._scrollStartPos.x - this.getScrollLeft())); const r = Math.floor(this._startPos.y + (this._scrollStartPos.y - this.getScrollTop())); this._selectionRect.x = Math.min(i, n.x), this._selectionRect.y = Math.min(r, n.y), this._selectionRect.width = Math.max(i, n.x) - this._selectionRect.x, this._selectionRect.height = Math.max(r, n.y) - this._selectionRect.y, this._clickAllowed && (this._clickAllowed = this._selectionRect.height <= this._consts.clickThreshold && this._selectionRect.width <= this._consts.clickThreshold); } return n; } }, { key: '_cleanUpSelection', value() { this._emitDragFinishedEvent(), this._startPos = null, this._drag = null, this._startedDragWithCtrl = !1, this._startedDragWithShiftKey = !1, this._selectionRect = null, this._clickTimeout = null, this._scrollStartPos = null, this._isPanStarted = !1, this._clickAllowed = !1, this._stopAutoPan(); } }, { key: '_clickTimeoutIsOver', value() { return !!(this._clickTimeout && Date.now() - this._clickTimeout > this._consts.clickDetectionMs); } }, { key: '_startAutoPan', value() { const e = this; this._consts.autoPanSpeed && (this._intervalRef || (this._intervalRef = setInterval((() => { e._handleMouseMoveEvent(null); }), this._consts.autoPanSpeed))); } }, { key: '_stopAutoPan', value() { this._intervalRef && (clearInterval(this._intervalRef), this._intervalRef = null), this._autoPanLastActionDate = null; } }, { key: '_checkUpdateSpeedTooFast', value() { return !!(this._autoPanLastActionDate && Date.now() - this._autoPanLastActionDate <= 10) || (this._autoPanLastActionDate = Date.now(), !1); } }, { key: '_scrollByPan', value(e, t, n) { if (e && t) { const i = Math.round(e.x - t.x); const r = n.x + i; i > 0 && this._rescaleInternal(r + this._width()), i > 0 && r + this._width() >= this._scrollContainer.scrollWidth - 5 ? this._scrollContainer.scrollLeft = this._scrollContainer.scrollWidth : this._scrollContainer.scrollLeft = r, this._scrollContainer.scrollTop = Math.round(n.y + e.y - t.y); } } }, { key: '_scrollBySelectionOutOfBounds', value(e) { const t = e.x; const n = e.y; let i = !1; let r = 0; let o = 0; const l = this._consts.autoPanByScrollPadding; const a = t <= l; const s = t >= this._width() - l; const u = n <= l; const h = n >= this._height() - l; let f = null; let _ = null; if (a || s || u || h) { if (this._startAutoPan(), this._checkUpdateSpeedTooFast()) return !1; const d = isNaN(this._consts.scrollByDragSpeed) ? 1 : this._consts.scrollByDragSpeed; a ? r = -c.getDistance(t, l) * d : s && (r = c.getDistance(t, this._width() - l) * d, f = this.getScrollLeft() + this._width() + r), u ? o = -c.getDistance(t, l) * d / 4 : h && (o = c.getDistance(t, this._height() - l) * d / 4, _ = this._scrollContainer.scrollTop + this._height()); } else this._stopAutoPan(); return (f || _) && this._rescaleInternal(f, _, 'scrollBySelection'), Math.abs(r) > 0 && (this._scrollContainer.scrollLeft += r, i = !0), Math.abs(o) > 0 && (this._scrollContainer.scrollTop += o, i = !0), i; } }, { key: 'pxToVal', value(e) { if (!this._options) return e; let t = this._options.min; c.isNumber(t) || (t = 0), t *= this._currentZoom || 1; const n = this._options.stepVal * this._currentZoom || 1; return t + e / this._options.stepPx * n; } }, { key: '_toScreenPx', value(e) { return this.valToPx(e) - this.getScrollLeft() + this._leftMargin(); } }, { key: '_fromScreen', value(e) { return this.pxToVal(this.getScrollLeft() + e - this._leftMargin()); } }, { key: 'valToPx', value(e) { if (!this._options) return e; let t = this._options.min; c.isNumber(t) || (t = 0), t *= this._currentZoom || 1; const n = this._options.stepVal * this._currentZoom || 1; return (-t + e) * (this._options.stepPx / n); } }, { key: 'snapVal', value(e) { if (this._options && this._options.snapEnabled && this._options.snapStep) { const t = this._options.snapStep; const n = e / t; const i = Math.round(n); const r = Math.abs(this._options.min) / this._options.snapStep; const o = c.sign(this._options.min) * (r - Math.floor(r)) * this._options.snapStep; e = Math.round(o) + Math.round(i * t); } return e = c.keepInBounds(e, this._options.min, this._options.max); } }, { key: '_mousePosToVal', value(e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = Math.min(e, this._width()); let i = this._fromScreen(n); return i = Math.round(i), t && (i = this.snapVal(i)), i; } }, { key: '_formatUnitsText', value(e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = c.sign(e) < 0 ? '-' : ''; let i = (e = Math.abs(e)) / 1e3; t && (i = e); const r = Math.floor(i / 31536e3); i %= 31536e3; const o = Math.floor(i / 86400); i %= 86400; const l = Math.floor(i / 3600); i %= 3600; const a = Math.floor(i / 60); i %= 60; let s = ''; return r && (s += `${r}:`), o && (s += `${o}:`), l && (s += `${l}:`), a && (s += `${a}:`), isNaN(i) || (s += i), n + s; } }, { key: '_leftMargin', value() { return this._options && this._options.leftMargin || 0; } }, { key: '_renderTicks', value() { if (this._ctx && this._options && this._ctx.canvas && this._ctx.canvas.clientWidth > 0 && this._ctx.canvas.clientHeight > 0 && this._options.stepPx) { const e = this._width() - this._leftMargin(); let t = this.pxToVal(this.getScrollLeft()); let n = this.pxToVal(this.getScrollLeft() + e); if (!isNaN(t) && !isNaN(n) && t !== n) { if (n < t) { const i = n; n = t, t = i; } const r = c.getDistance(t, n); if (!(r <= 0)) { const o = c.findGoodStep(r / (e / this._options.stepPx)); const l = c.findGoodStep(r / (e / this._options.stepSmallPx)); const a = Math.floor(t / o) * o; const s = Math.ceil(n / o) * o + o; if (c.isNumber(o) && !(o <= 0) && Math.abs(s - a) !== 0) { let u = 0; this._ctx.save(); for (let h = v.headerHeight(this._options), f = h / 2, _ = h / 1.3, d = a; d <= s; d += o) { const p = this._getSharp(this._toScreenPx(d)); this._ctx.save(), this._ctx.beginPath(), this._ctx.setLineDash([4]), this._ctx.lineWidth = 1, this._ctx.strokeStyle = this._options.tickColor, c.drawLine(this._ctx, p, f, p, h), this._ctx.stroke(), this._ctx.fillStyle = this._options.labelsColor, this._options.font && (this._ctx.font = this._options.font); const m = this._formatUnitsText(d); const y = this._ctx.measureText(m); const g = p - y.width / 2; if ((isNaN(u) || u <= g) && (u = g + y.width, this._ctx.fillText(m, g, 10)), this._ctx.restore(), c.isNumber(l) && !(l <= 0)) for (let w = d + l; w < d + o; w += l) { const b = this._getSharp(this._toScreenPx(w)); this._ctx.beginPath(), this._ctx.lineWidth = this._pixelRatio, this._ctx.strokeStyle = this._options.tickColor, c.drawLine(this._ctx, b, _, b, h), this._ctx.stroke(); } } this._ctx.restore(); } } } } } }, {
      key: '_calculateModel',
      value() {
        const e = this; const t = {
          rows: [],
          size: {
            x: 0, y: 0, width: 0, height: 0,
          },
          min: null,
          max: null,
          keyframes: [],
        }; if (!this._model) return t; const n = this._model.rows; if (!n || !Array.isArray(n) || n.length <= 0) return t; let i = v.headerHeight(this._options); return n.forEach(((n, r) => {
 if (n && !n.hidden) {
 const o = v.getRowHeight(n, e._options); const l = v.getRowMarginBottom(n, e._options); const a = i - (e._scrollContainer ? e._scrollContainer.scrollTop : 0); i += o + l, r == 0 && (t.size.y = a), t.size.height = Math.max(i + o, t.size.height); const s = {
          size: {
            x: 0, y: a, width: e._canvas ? e._width() : 0, height: o, 
          },
marginBottom: l,
model: n,
min: null,
max: null,
groups: [],
keyframes: [], 
        }; t.rows.push(s), !n.keyframes || !n.keyframes.forEach || n.keyframes.length <= 0 || (n && n.keyframes && n.keyframes.forEach(((n) => {
 if (n && !isNaN(n.val) && !n.hidden) {
 for (var i = null, r = 0; r < s.groups.length; r++) { let o = s.groups[r]; if (n.group === o.group) { i = o; break; } }i || (i = {
 min: null, max: null, group: n.group, keyframes: [],
        }, s.groups.push(i)); let l = e._getKeyframePosition(n, s); let a = { model: n, parentRow: s, parentGroup: i, size: l
}; let c = null == i.min ? n.val:Math.min(n.val, i.min); let u = i.max == null ? n.val : Math.max(n.val, i.max); isNaN(c) || (i.min = c), isNaN(u) || (i.max = u), s.keyframes.push(a), i.keyframes.push(a), t.keyframes.push(a);
} 
})), s.groups.forEach(((t) => { c.setMinMax(s, t, !0); let i = e._getKeyframesGroupSize(n, s.size.y, t.min, t.max); t.size = i; })), c.setMinMax(t, s, !0)); 
} 
})), c.isNumber(t.max) && (t.size.width = this.valToPx(t.max)), t;
      },
    }, { key: '_renderRows', value() { const e = this; const t = this._calculateModel(); t && t.rows && (this._ctx.save(), t.rows.forEach(((t) => { if (t) { e._ctx.fillStyle = v.getRowFillColor(t.model, e._options); const n = e._cutBounds(t.size); n && e._ctx.fillRect(n.x, n.y, n.width, n.height); const i = v.groupFillColor(t.model, e._options); t.groups && t.groups.forEach(((t) => { let n = e._cutBounds(t.size); n && (e._ctx.fillStyle = i, e._ctx.fillRect(n.x, n.y, n.width, n.height)); })); } })), this._ctx.restore()); } }, {
      key: '_cutBounds',
      value(e) {
        if (!e) return null; const t = this._width(); const n = v.headerHeight(this._options); const i = this._width(); if (c.isRectOverlap(e, {
          x: 0, y: n, width: c.getDistance(0, t), height: c.getDistance(n, i),
        })) {
          const r = Math.max(e.y, n); const o = Math.max(e.x, 0); const l = e.x - o; const a = e.y - r; return {
            height: e.height + a, width: e.width + l, x: o, y: r, overlapY: Math.abs(a) > 0, overlapX: Math.abs(l) > 0,
          };
        } return null;
      },
    }, {
      key: '_getKeyframesGroupSize',
      value(e, t, n, i) {
        let r = v.rowGroupHeight(e, this._options); const o = v.getRowHeight(e, this._options); (!r && r !== 0 || isNaN(r) || r == 'auto') && (r = Math.floor(0.7 * o)), r > o && (r = o); const l = o - r; const a = this._toScreenPx(n); const s = this._toScreenPx(i); return {
          x: a, y: t + Math.floor(l / 2), height: r, width: c.getDistance(a, s),
        };
      },
    }, {
      key: '_getKeyframePosition',
      value(e, t) {
        if (!e) return console.log('keyframe should be defined.'), null; const n = e.val; if (isNaN(n)) return null; const i = t.size; const r = i.y + i.height / 2; let o = v.getKeyframeStyle(e, t.model, this._options, 'height', 'auto'); let l = v.getKeyframeStyle(e, t.model, this._options, 'width', 'auto'); return o == 'auto' && (o = i.height / 3), l == 'auto' && (l = o), o > 0 && !isNaN(n) ? {
          x: Math.floor(this._toScreenPx(n)), y: Math.floor(r), height: o, width: l,
        } : null;
      },
    }, {
 key: '_renderKeyframes',
value() {
 const e = this; this._forEachKeyframe(((t) => {
 const n = t.parentRow.model; const i = t.size; const r = t.model; if (i) {
 let o = e._getSharp(i.x); let l = i.y; const s = e._cutBounds({
      x: o - i.width / 2, y: l - i.height / 2, width: i.width, height: i.height, 
    }); if (!s) return; e._ctx.save(), s && s.overlapY && (e._ctx.beginPath(), e._ctx.rect(0, v.headerHeight(e._options), e._width(), e._width()), e._ctx.clip()); const c = v.keyframeShape(r, n, e._options); if (c === a.None) return; const u = r.selected ? v.keyframeSelectedFillColor(r, n, e._options) : v.keyframeFillColor(r, n, e._options); const h = v.keyframeStrokeThickness(r, n, e._options); const f = h > 0 ? r.selected ? v.keyframeSelectedStrokeColor(r, n, e._options) : v.keyframeStrokeColor(r, n, e._options) : ''; c == a.Rhomb ? (e._ctx.beginPath(), e._ctx.translate(o, l), e._ctx.rotate(45 * Math.PI / 180), h > 0 && f && (e._ctx.fillStyle = f, e._ctx.rect(-i.width / 2, -i.height / 2, i.width, i.height), e._ctx.fill()), e._ctx.fillStyle = u, e._ctx.translate(h, h), e._ctx.rect(-i.width / 2, -i.height / 2, i.width - 2 * h, i.height - 2 * h), e._ctx.fill()) : c == a.Circle ? (e._ctx.beginPath(), h > 0 && f && (e._ctx.fillStyle = f, e._ctx.arc(o, l, i.height, 0, 2 * Math.PI)), e._ctx.fillStyle = u, e._ctx.arc(o, l, i.height - h, 0, 2 * Math.PI), e._ctx.fill()) : c == a.Rect && (e._ctx.beginPath(), l -= i.height / 2, o -= i.width / 2, h > 0 && f && (e._ctx.fillStyle = f, e._ctx.rect(o, l, i.width, i.height), e._ctx.fill()), e._ctx.fillStyle = u, e._ctx.rect(o + h, l + h, i.width - h, i.height - h), e._ctx.fill()), e._ctx.restore(); 
} 
})); 
} 
}, { key: '_renderSelectionRect', value() { this._drag || (this._ctx.save(), this._selectionRect && this._selectionRectEnabled && (this._ctx.setLineDash([4]), this._ctx.lineWidth = this._pixelRatio, this._ctx.strokeStyle = this._options.selectionColor, this._ctx.strokeRect(this._getSharp(this._selectionRect.x, 1), this._getSharp(this._selectionRect.y, 1), Math.floor(this._selectionRect.width), Math.floor(this._selectionRect.height))), this._ctx.restore()); } }, { key: '_renderBackground', value() { this._options.fillColor ? (this._ctx.save(), this._ctx.beginPath(), this._ctx.rect(0, 0, this._width(), this._height()), this._ctx.fillStyle = this._options.fillColor, this._ctx.fill(), this._ctx.restore()) : this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height); } }, { key: '_renderTimeline', value() { if (this._ctx && this._options && this._options.timelineStyle) { const e = this._options.timelineStyle; this._ctx.save(); const t = e.width || 1; this._ctx.lineWidth = t * this._pixelRatio; const n = this._getSharp(this._toScreenPx(this._val), t); this._ctx.strokeStyle = e.strokeColor, this._ctx.fillStyle = e.fillColor; const i = e.marginTop; if (this._ctx.beginPath(), c.drawLine(this._ctx, n, i, n, this._height()), this._ctx.stroke(), e.capHeight && e.capWidth) { const r = e.capWidth; const o = e.capHeight; e.capType === _.Triangle ? (this._ctx.beginPath(), this._ctx.moveTo(n - r / 2, i), this._ctx.lineTo(n + r / 2, i), this._ctx.lineTo(n, o), this._ctx.closePath(), this._ctx.stroke()) : e.capType === _.Rect && (this._ctx.fillRect(n - r / 2, i, r, o), this._ctx.fill()); } this._ctx.restore(); } } }, { key: '_renderHeaderBackground', value() { this._ctx && this._options && v.headerHeight(this._options) && (this._ctx.save(), this._ctx.lineWidth = this._pixelRatio, this._options.headerFillColor ? (this._ctx.lineWidth = this._pixelRatio, this._ctx.fillStyle = this._options.headerFillColor, this._ctx.fillRect(0, 0, this._width(), v.headerHeight(this._options))) : this._ctx.clearRect(0, 0, this._width(), v.headerHeight(this._options)), this._ctx.restore()); } }, { key: 'redraw', value() { window.requestAnimationFrame ? window.requestAnimationFrame(this._redrawInternal) : this._redrawInternal(); } }, { key: 'scrollLeft', value() { this._scrollContainer.scrollLeft != this._scrollContainer.scrollWidth && (this._scrollContainer.scrollLeft = this._scrollContainer.scrollWidth); } }, { key: 'getRowByY', value(e) { const t = this._calculateModel(); if (t && t.rows) for (let n = 0; n < t.rows.length; n++) { const i = t.rows[n].size; if (i && i.y >= e && e <= i.y + i.height) return i; } return null; } }, { key: '_getSharp', value(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1; return e = Math.round(e), t % 2 == 0 ? e : e + this._pixelRatio / 2; } }, { key: 'getTime', value() { return this._val; } }, { key: '_setTimeInternal', value(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Z.Programmatically; if ((e = Math.round(e)) < this._options.min && (e = this._options.min), this._val != e) { const n = this._val; const i = new le(); return i.val = e, i.prevVal = n, i.source = t, this._val = e, this.emit(f.TimeChanged, i), !i.isPrevented() || (this._val = n, !1); } return !1; } }, { key: 'setTime', value(e) { if (this._drag && this._drag.type === h.Timeline) return !1; const t = this._setTimeInternal(e, Z.SetTimeMethod); return t && (this.rescale(), this.redraw()), t; } }, { key: 'getOptions', value() { return this._options; } }, { key: 'setScrollLeft', value(e) { this._scrollContainer && (this._scrollContainer.scrollLeft = e); } }, { key: 'setScrollTop', value(e) { this._scrollContainer && (this._scrollContainer.scrollTop = e); } }, { key: 'getScrollLeft', value() { return this._scrollContainer ? this._scrollContainer.scrollLeft : 0; } }, { key: 'getScrollTop', value() { return this._scrollContainer ? this._scrollContainer.scrollTop : 0; } }, { key: 'setOptions', value(e) { return this._options = this._setOptions(e), this.rescale(), this.redraw(), this._options; } }, { key: '_setOptions', value(e) { if (this._options = this._mergeOptions(e), this._options.snapStep = c.keepInBounds(this._options.snapStep, 0, this._options.stepVal), this._currentZoom = this._setZoom(this._options.zoom, this._options.zoomMin, this._options.zoomMax), this._options.min = c.isNumber(this._options.min) ? this._options.min : 0, this._options.max = c.isNumber(this._options.max) ? this._options.max : Number.MAX_VALUE, this._scrollContainer) { const t = this._scrollContainer.classList; this._options.scrollContainerClass && t.contains(this._options.scrollContainerClass) && t.add(this._options.scrollContainerClass), this._options.fillColor && (this._scrollContainer.style.background = this._options.fillColor); } return this._options; } }, { key: 'getModel', value() { return this._model; } }, { key: 'setModel', value(e) { this._model = e, this.rescale(), this.redraw(); } }, {
      key: '_getMousePos',
      value(e, t) {
        let n = 1; let i = 0; let r = 0; if (t.changedTouches && t.changedTouches.length > 0) { const o = t.changedTouches[0]; i = o.clientX, r = o.clientY, n = Math.max(n, o.radiusX, o.radiusY); } else i = t.clientX, r = t.clientY; const l = e.getBoundingClientRect(); const a = e.width / this._pixelRatio / l.width; const s = e.height / this._pixelRatio / l.height; return {
          x: (i - l.left) * a, y: (r - l.top) * s, radius: n, args: t,
        };
      },
    }, { key: '_updateCanvasScale', value() { if (this._scrollContainer && this._ctx) { let e = !1; const t = this._scrollContainer.clientWidth * this._pixelRatio; const n = this._scrollContainer.clientHeight * this._pixelRatio; return Math.floor(t) != Math.floor(this._ctx.canvas.width) && (this._ctx.canvas.width = t, e = !0), Math.floor(n) != Math.floor(this._ctx.canvas.height) && (this._ctx.canvas.height = n, e = !0), e && this._ctx.setTransform(this._pixelRatio, 0, 0, this._pixelRatio, 0, 0), e; }console.log('control should be initialized first'); } }, { key: 'rescale', value() { this._rescaleInternal(); } }, { key: '_rescaleInternal', value() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'default'; this._updateCanvasScale(); const i = this._calculateModel(); if (i && i.size) { const r = this._options.stepPx; e = e || 0; const o = this.valToPx(this._val); let l = 0; o > this._width() && (l = n == 'scrollBySelection' ? Math.floor(o + this._width() + (this._options.stepPx || 0)) : Math.floor(o + this._width() / 1.5)); const a = i.size.width + this._leftMargin() + r; e = Math.max(e, a, this.getScrollLeft() + this._width(), l); const s = `${Math.floor(e)}px`; s != this._scrollContent.style.minWidth && (this._scrollContent.style.minWidth = s); const c = `${t = Math.max(Math.floor(i.size.height + 0.2 * this._height()), this._scrollContainer.scrollTop + this._height() - 1, Math.round(t || 0))}px`; this._scrollContent.style.minHeight != c && (this._scrollContent.style.minHeight = c); } } }, { key: '_findDraggable', value(e) { const t = this; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const i = function (e) { return e === h.Timeline ? 1 : e === h.Keyframe ? 2 : e === h.Group ? 3 : -1; }; const r = e.filter(((e) => { if (!e) return !1; if (e.type === h.Keyframe) { if (!v.keyframeDraggable(e.keyframe, e.row, t._options)) return !1; } else if (e.type === h.Group) { if (!v.groupDraggable(e.row, t._options)) return !1; } else if (e.type === h.Row) return !1; return !0; })); const o = r.sort(((e, t) => { let r = i(e.type); let o = i(t.type); return r !== o || n !== null && (r = c.getDistance(e.val, n)) !== (o = c.getDistance(t.val, n)) ? r < o ? 1 : -1 : 0; })); return o.length > 0 ? o[o.length - 1] : null; } }, {
      key: 'elementFromPoint',
      value(e) {
        const t = this; let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2; n = Math.max(n, 1); const i = []; if (!e) return i; const r = v.headerHeight(this._options); const o = this._toScreenPx(this._val); let l = 0; if (this._options && this._options.timelineStyle) { const a = this._options.timelineStyle; l = Math.max((a.width || 1) * this._pixelRatio, (a.capWidth || 0) * this._pixelRatio || 1) + n; }(e.y <= 0.5 * r || e.x >= o - l / 2 && e.x <= o + l / 2) && i.push({ val: this._val, type: h.Timeline }); const s = this._options.snapEnabled; return e.y >= r && this._options.keyframesDraggable && this._forEachKeyframe(((r, o, l) => {
          if (l) {
            if (c.isOverlap(e.x, e.y, r.parentRow.size)) {
              let a = {
                val: t._mousePosToVal(e.x, s), keyframes: r.parentRow.model.keyframes, type: h.Row, row: r.parentRow.model,
              }; i.push(a);
            }r.parentRow.groups && r.parentRow.groups.forEach(((n) => { if (c.isOverlap(e.x, e.y, n.size)) { let o = t._mapKeyframes(n.keyframes); let l = { val: t._mousePosToVal(e.x, s), type: h.Group, group: n, row: r.parentRow.model, keyframes: o }; let a = t.snapVal(n.min); l.val += n.min - a, i.push(l); } }));
          } const u = r.size; u && c.getDistance(u.x, u.y, e.x, e.y) <= u.height + n && i.push({
            keyframe: r.model, keyframes: [r.model], val: r.model.val, row: r.parentRow.model, type: h.Keyframe,
          });
        })), i;
      }, 
    }, { key: '_mergeOptions', value(e) { e = e || {}; const t = JSON.parse(JSON.stringify(X)); return (function e(t, n) { if (t && n) for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && void 0 !== n[i] && (pe(n[i]) === 'object' && t[i] ? e(t[i], n[i]) : t[i] = n[i]); }(t, e)), t; } }, { key: 'onTimeChanged', value(e) { this.on(f.TimeChanged, e); } }, { key: 'onDragStarted', value(e) { this.on(f.DragStarted, e); } }, { key: 'onDrag', value(e) { this.on(f.Drag, e); } }, { key: 'onDragFinished', value(e) { this.on(f.DragFinished, e); } }, { key: 'onDoubleClick', value(e) { this.on(f.DoubleClick, e); } }, { key: 'onKeyframeChanged', value(e) { this.on(f.KeyframeChanged, e); } }, { key: 'onMouseDown', value(e) { this.on(f.MouseDown, e); } }, { key: 'onSelected', value(e) { this.on(f.Selected, e); } }, { key: 'onScroll', value(e) { this.on(f.Scroll, e); } }, {
      key: '_emitScrollEvent',
      value(e) {
        const t = {
          args: e, scrollLeft: this.getScrollLeft(), scrollTop: this.getScrollTop(), scrollHeight: this._scrollContainer.scrollHeight, scrollWidth: this._scrollContainer.scrollWidth,
        }; return xe(Se(o.prototype), 'emit', this).call(this, f.Scroll, t), t;
      },
    }, { key: '_emitKeyframeChanged', value(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Z.Programmatically; const n = new ve(); return n.val = e.val, n.prevVal = e.prevVal, n.target = e, n.source = t, this.emit(f.KeyframeChanged, n), n; } }, { key: '_emitDragStartedEvent', value() { const e = this._getDragEventArgs(); return this.emit(f.DragStarted, e), e.isPrevented() && this._preventDrag(e, this._drag, !0), e; } }, { key: '_emitDragFinishedEvent', value() { if (this._drag && this._drag.changed) { const e = this._getDragEventArgs(); return this.emit(f.DragFinished, e), e.isPrevented() && this._preventDrag(e, this._drag, !0), e; } return null; } }, { key: '_preventDrag', value(e, t) { const n = this; const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; e.elements && e.elements.forEach(((e) => { const t = i ? e.startedVal : e.prevVal; n._setKeyframePos(e, t); })), t.val = t.prevVal, e.val = e.prevVal; } }, { key: '_emitDragEvent', value() { if (!this._drag) return null; const e = this._getDragEventArgs(); return this.emit(f.Drag, e), e.isPrevented() && this._preventDrag(e, this._drag, !1), e; } }, { key: '_emitKeyframesSelected', value(e) { const t = new C(); return t.selected = e.selected, t.changed = e.changed, this.emit(f.Selected, t), t; } }, { key: '_getDragEventArgs', value() { const e = new U(); return this._drag ? (e.val = this._currentPos.val, e.originalVal = this._currentPos.originalVal, e.snapVal = this._currentPos.snapVal, e.pos = this._currentPos, e.elements = this._drag.elements, e.target = this._drag.target, e) : e; } }]) && ye(t.prototype, n), i && ye(t, i), o;
  }(r)); var Te = n(2); var Pe = n(3); var Re = n(4); var Ee = n(5); var De = n(6); var Oe = n(7); var Ke = n(8); var ze = n(9); var Ne = n(10); var Le = n(11); var je = n(12); var Ae = n(13); var Ve = n(14); var We = n(15); var Fe = n(16); var Be = n(1); var Ie = n(0); var Ze = n(17);
}])))));
